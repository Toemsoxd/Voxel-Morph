<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, touch-action=none">
    <title>Voxel Morph: Multiplayer 游댦</title>
    
    <!-- Favicon de Emoji 游댦 -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>游댦</text></svg>">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { touch-action: none; overflow: hidden; background-color: black; }
        canvas { touch-action: none; display: block; }
    </style>
</head>
<body class="bg-black select-none">

    <!-- Capa de Men칰 / Lobby -->
    <div id="menu" class="fixed inset-0 flex items-center justify-center bg-black/80 z-50 overflow-hidden pointer-events-auto">
        <div class="bg-zinc-900 p-8 rounded-2xl border border-zinc-700 text-center max-w-md w-full mx-4 shadow-2xl">
            <h1 class="text-4xl font-black text-white mb-2 tracking-tighter">VOXEL MORPH 游댦</h1>
            <p id="lobby-status" class="text-zinc-400 mb-6 italic text-sm">Cargando configuraci칩n...</p>
            
            <div id="controls-container" class="space-y-4">
                <div id="player-status-msg" class="text-amber-500 text-xs font-bold uppercase tracking-widest mb-2"></div>
                <button id="btn-start" style="display: none;" disabled class="w-full py-4 bg-zinc-700 text-zinc-500 font-bold rounded-xl transition-all cursor-not-allowed opacity-50">
                    ESPERANDO JUGADORES (0/5)
                </button>
            </div>

            <div class="mt-8 flex items-center justify-between p-4 bg-zinc-800 rounded-xl">
                <span class="text-white font-medium text-sm">Controles T치ctiles</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="touch-toggle" class="sr-only peer">
                    <div class="w-11 h-6 bg-zinc-600 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-500"></div>
                </label>
            </div>
            <p class="text-zinc-500 text-[10px] mt-4 uppercase tracking-widest">M칤nimo 5 personas para jugar</p>
        </div>
    </div>

    <!-- Interfaz de Juego -->
    <div id="ui-layer" class="fixed inset-0 pointer-events-none z-10">
        <div id="crosshair" class="absolute top-1/2 left-1/2 w-5 h-5 -translate-x-1/2 -translate-y-1/2 border-2 border-white rounded-full mix-blend-difference hidden"></div>
        <div id="status" class="absolute top-6 left-6 text-white bg-black/50 p-3 rounded-lg font-mono text-sm hidden">
            HP: <span id="hp">100</span> | LOBBY: <span id="player-count">0</span>
        </div>
        
        <div id="joystick-zone" class="absolute bottom-10 left-10 w-40 h-40 hidden pointer-events-auto">
            <div class="absolute inset-0 bg-white/10 rounded-full border border-white/20"></div>
            <div id="move-knob" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-16 h-16 bg-white rounded-full shadow-xl opacity-80"></div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, collection, query, deleteDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- MANEJO DE CONFIGURACI칍N PARA GITHUB ---
        // Si est치s en GitHub, reemplaza el objeto {} por tu configuraci칩n de Firebase Console
        let config;
        try {
            config = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
                apiKey: "TU_API_KEY",
                authDomain: "TU_PROYECTO.firebaseapp.com",
                projectId: "TU_PROYECTO_ID",
                storageBucket: "TU_PROYECTO.appspot.com",
                messagingSenderId: "ID",
                appId: "APP_ID"
            };
        } catch (e) {
            console.error("Configuraci칩n no encontrada");
        }

        const app = initializeApp(config);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'voxel-morph-prod';

        // --- VARIABLES DE ESTADO ---
        let scene, camera, renderer, clock;
        let player, terrainMesh;
        let touchEnabled = false;
        let moveJoystick = { active: false, x: 0, y: 0, identifier: null };
        let remotePlayers = {}, powerUps = [];
        let gameInitialized = false;
        let isHost = false;
        let currentUser = null;
        let lobbyData = null;
        let totalConnected = 0;
        let cameraDistance = 5, targetCameraDistance = 5;
        let pitch = 0, yaw = 0;
        let lastPinchDist = 0;
        let lookTouchIdentifier = null;
        let lastLookX = 0, lastLookY = 0;
        const MIN_PLAYERS = 5;
        const keys = {};
        const raycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);

        // --- L칍GICA DE FIREBASE ---
        const initLobby = async () => {
            document.getElementById('lobby-status').innerText = "Conectando...";
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (err) { console.error("Error Auth:", err); }

            onAuthStateChanged(auth, async (user) => {
                if (!user) return;
                currentUser = user;
                const lobbyRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobby_state', 'main');
                
                onSnapshot(lobbyRef, (docSnap) => {
                    const data = docSnap.data();
                    if (!data) { createLobby(); return; }
                    lobbyData = data;
                    updateLobbyUI();
                    if (data.status === 'playing' && !gameInitialized) startSimulation();
                });

                const playersCol = collection(db, 'artifacts', appId, 'public', 'data', 'players');
                onSnapshot(playersCol, (snapshot) => {
                    totalConnected = snapshot.size;
                    snapshot.docChanges().forEach(change => {
                        if (change.doc.id === currentUser.uid) return;
                        if (change.type === "added" || change.type === "modified") updateRemotePlayer(change.doc.id, change.doc.data());
                        else if (change.type === "removed") removeRemotePlayer(change.doc.id);
                    });
                    document.getElementById('player-count').innerText = totalConnected;
                    updateLobbyUI();
                });

                const puCol = collection(db, 'artifacts', appId, 'public', 'data', 'powerups');
                onSnapshot(puCol, (snapshot) => {
                    snapshot.docChanges().forEach(change => {
                        if (change.type === "added") spawnPowerUpMesh(change.doc.id, change.doc.data());
                        if (change.type === "removed") removePowerUpMesh(change.doc.id);
                    });
                });
            });
        };

        const createLobby = async () => {
            const lobbyRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobby_state', 'main');
            isHost = true;
            await setDoc(lobbyRef, { hostId: currentUser.uid, status: 'waiting', createdAt: serverTimestamp() });
        };

        const updateLobbyUI = () => {
            const statusEl = document.getElementById('lobby-status');
            const startBtn = document.getElementById('btn-start');
            const pStatus = document.getElementById('player-status-msg');
            
            if (lobbyData) {
                isHost = lobbyData.hostId === currentUser.uid;
                const canStart = totalConnected >= MIN_PLAYERS;
                statusEl.innerText = isHost ? "Eres el HOST" : "Conectado al Lobby";

                if (isHost) {
                    startBtn.style.display = 'block';
                    startBtn.innerText = canStart ? "INICIAR PARTIDA" : `ESPERANDO (${totalConnected}/${MIN_PLAYERS})`;
                    startBtn.disabled = !canStart;
                    startBtn.className = canStart ? 
                        "w-full py-4 bg-white text-black font-bold rounded-xl hover:bg-blue-400 transition-all" : 
                        "w-full py-4 bg-zinc-700 text-zinc-500 font-bold rounded-xl cursor-not-allowed opacity-50";
                } else {
                    startBtn.style.display = 'none';
                    pStatus.innerText = canStart ? "El host iniciar치 pronto..." : `Esperando jugadores (${totalConnected}/${MIN_PLAYERS})`;
                }
            }
        };

        const startSimulation = async () => {
            if (isHost) {
                const lobbyRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobby_state', 'main');
                await updateDoc(lobbyRef, { status: 'playing' });
                generatePowerUpsInDB();
            }
            document.getElementById('menu').style.display = 'none';
            initEngine();
            animate();
        };

        // --- CONTROLES T츼CTILES ---
        const initTouchControls = () => {
            const zone = document.getElementById('joystick-zone');
            const knob = document.getElementById('move-knob');

            window.addEventListener('touchstart', (e) => {
                if (!touchEnabled) return;
                for (let touch of e.changedTouches) {
                    if (touch.clientX < window.innerWidth / 2 && !moveJoystick.active) {
                        moveJoystick.active = true;
                        moveJoystick.identifier = touch.identifier;
                        updateJoystick(touch.clientX, touch.clientY);
                    } else if (lookTouchIdentifier === null) {
                        lookTouchIdentifier = touch.identifier;
                        lastLookX = touch.clientX; lastLookY = touch.clientY;
                    }
                }
            });

            window.addEventListener('touchmove', (e) => {
                if (!touchEnabled) return;
                e.preventDefault();
                if (e.touches.length === 2) {
                    const d = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                    if (lastPinchDist > 0) targetCameraDistance = Math.max(0, Math.min(12, targetCameraDistance + (lastPinchDist - d) * 0.05));
                    lastPinchDist = d;
                    return;
                }
                for (let touch of e.changedTouches) {
                    if (touch.identifier === moveJoystick.identifier) updateJoystick(touch.clientX, touch.clientY);
                    else if (touch.identifier === lookTouchIdentifier) {
                        yaw -= (touch.clientX - lastLookX) * 0.005;
                        pitch = Math.max(-1.4, Math.min(1.4, pitch - (touch.clientY - lastLookY) * 0.005));
                        lastLookX = touch.clientX; lastLookY = touch.clientY;
                    }
                }
            }, { passive: false });

            window.addEventListener('touchend', (e) => {
                lastPinchDist = 0;
                for (let touch of e.changedTouches) {
                    if (touch.identifier === moveJoystick.identifier) {
                        moveJoystick.active = false; moveJoystick.x = 0; moveJoystick.y = 0;
                        knob.style.transform = `translate(-50%, -50%)`;
                    }
                    if (touch.identifier === lookTouchIdentifier) lookTouchIdentifier = null;
                }
            });

            function updateJoystick(tx, ty) {
                const rect = zone.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2, centerY = rect.top + rect.height / 2;
                const dx = tx - centerX, dy = ty - centerY;
                const dist = Math.min(rect.width / 2, Math.hypot(dx, dy));
                const angle = Math.atan2(dy, dx);
                knob.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
                moveJoystick.x = (Math.cos(angle)*dist) / (rect.width/2);
                moveJoystick.y = (Math.sin(angle)*dist) / (rect.height/2);
            }
        };

        // --- ENGINE 3D ---
        function initEngine() {
            if (gameInitialized) return;
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.FogExp2(0x87ceeb, 0.01);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            scene.add(new THREE.DirectionalLight(0xffffff, 1), new THREE.AmbientLight(0xffffff, 0.5));
            clock = new THREE.Clock();
            generateTerrain();
            createPlayer();
            initTouchControls();
            gameInitialized = true;
            document.getElementById('crosshair').classList.remove('hidden');
            document.getElementById('status').classList.remove('hidden');
            setInterval(syncPlayerData, 100);
        }

        function generateTerrain() {
            const geo = new THREE.PlaneGeometry(160, 160, 80, 80);
            const pos = geo.attributes.position;
            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i), z = pos.getY(i);
                pos.setZ(i, Math.abs(x)>78 || Math.abs(z)>78 ? 15 : Math.sin(x*0.08)*Math.cos(z*0.08)*4 + Math.sin(x*0.04+z*0.04)*6);
            }
            geo.computeVertexNormals();
            terrainMesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0x44aa44 }));
            terrainMesh.rotation.x = -Math.PI / 2;
            scene.add(terrainMesh);
        }

        function createPlayer() {
            player = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0x2196f3 });
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.4), mat); body.position.y = 0.6;
            player.add(body); player.mesh = body;
            scene.add(player); player.position.set(0, 10, 0); player.velocity = new THREE.Vector3(); player.hp = 100;
        }

        const syncPlayerData = async () => {
            if (!gameInitialized || !currentUser) return;
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'players', currentUser.uid), {
                pos: { x: player.position.x, y: player.position.y, z: player.position.z },
                rot: player.mesh.rotation.y, hp: player.hp, lastSeen: serverTimestamp()
            });
        };

        const generatePowerUpsInDB = async () => {
            const col = collection(db, 'artifacts', appId, 'public', 'data', 'powerups');
            for(let i=0; i<12; i++) await setDoc(doc(col), { x: Math.random()*120-60, z: Math.random()*120-60, type: Math.random()>0.5?'health':'ammo' });
        };

        const spawnPowerUpMesh = (id, data) => {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshStandardMaterial({ color: data.type==='health'?0xff4444:0xffcc44 }));
            mesh.position.set(data.x, 2, data.z); // Altura simplificada
            mesh.userData = { id, type: data.type };
            scene.add(mesh); powerUps.push(mesh);
        };

        const removePowerUpMesh = (id) => {
            const i = powerUps.findIndex(p => p.userData.id === id);
            if (i !== -1) { scene.remove(powerUps[i]); powerUps.splice(i, 1); }
        };

        const updateRemotePlayer = (id, data) => {
            if (!remotePlayers[id]) {
                remotePlayers[id] = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.4), new THREE.MeshStandardMaterial({ color: 0xff4444 }));
                scene.add(remotePlayers[id]);
            }
            remotePlayers[id].position.lerp(new THREE.Vector3(data.pos.x, data.pos.y, data.pos.z), 0.2);
        };

        const removeRemotePlayer = (id) => { if (remotePlayers[id]) { scene.remove(remotePlayers[id]); delete remotePlayers[id]; } };

        function updateMovement(delta) {
            let mx = 0, mz = 0;
            if (keys['KeyW']) mz -= 1; if (keys['KeyS']) mz += 1;
            if (keys['KeyA']) mx -= 1; if (keys['KeyD']) mx += 1;
            if (touchEnabled && moveJoystick.active) { mx = moveJoystick.x; mz = moveJoystick.y; }

            const dir = new THREE.Vector3(mx, 0, mz).normalize().applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
            player.position.add(dir.multiplyScalar(15 * delta));
            player.velocity.y -= 30 * delta;
            player.position.y += player.velocity.y * delta;
            
            // Suelo simple para demo
            if (player.position.y < 0) { player.position.y = 0; player.velocity.y = 0; }
            if (keys['Space'] && player.position.y <= 0) player.velocity.y = 10;
            
            powerUps.forEach(async pu => {
                if (player.position.distanceTo(pu.position) < 1.5) {
                    if (pu.userData.type === 'health') player.hp = Math.min(100, player.hp + 20);
                    try { await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'powerups', pu.userData.id)); } catch(e){}
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!gameInitialized) return;
            const delta = Math.min(clock.getDelta(), 0.1);
            updateMovement(delta);
            cameraDistance = THREE.MathUtils.lerp(cameraDistance, targetCameraDistance, 0.1);
            const targetPos = player.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            camera.position.copy(targetPos).add(new THREE.Vector3(0, 0, cameraDistance).applyAxisAngle(new THREE.Vector3(1,0,0), pitch).applyAxisAngle(new THREE.Vector3(0,1,0), yaw));
            camera.lookAt(targetPos);
            renderer.render(scene, camera);
            document.getElementById('hp').innerText = Math.round(player.hp);
        }

        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('mousemove', e => { if (document.pointerLockElement) { yaw -= e.movementX*0.002; pitch = Math.max(-1.4, Math.min(1.4, pitch - e.movementY*0.002)); } });
        window.addEventListener('wheel', e => targetCameraDistance = Math.max(0.5, Math.min(12, targetCameraDistance + e.deltaY*0.005)));
        window.addEventListener('mousedown', () => { if (gameInitialized && !touchEnabled) renderer.domElement.requestPointerLock(); });
        document.getElementById('btn-start').onclick = startSimulation;
        document.getElementById('touch-toggle').onchange = (e) => {
            touchEnabled = e.target.checked;
            document.getElementById('joystick-zone').style.display = touchEnabled ? 'block' : 'none';
        };

        window.onload = initLobby;
    </script>
</body>
</html>
